#include <iostream>
#include <string>
using namespace std;

//1. Назовите три шага по созданию функции.
	//--- Написати визначення фуккції
	//--- Написати прототип функції
	//--- Визвати функцію

//2. Постройте прототипы, которые соответствовали бы следующим описаниям.
	//а. igor() не принимает аргументов и не возвращает значения.
	void igor();
	//б. tofu() принимает аргумент int и возвращает float.
	float tofu(int);
	//в. mpg() принимает два аргумента типа double и возвращает double.
	double mpg(double, double);
	//г. summation() принимает имя массива long и его размер и возвращает значение long.
	long summation(long*, size_t);
	//д. doctor() принимает строковый аргумент(строка не должна изменяться) и возвращает double.
	double doctor(const string);
	//е. ofcourse() принимает структуру boss в качестве аргумента и не возвращает ничего.
	struct boss{};
	void ofcourse(boss);
	//ж. plot() принимает указатель на структуру map в качестве аргумента и возвращает строку.
	struct map{};
	string plot(map *stru);

//3. Напишите функцию, принимающую три - аргумента: имя массива int, его размер и значение int.Функция должна присвоить каждому элементу массива это значение int.
	void SetInt(int mas[], size_t size, int num)
	{
		while (size-- > 0)
		{
			mas[size] = num;
		}
	}

//4. Напишите функцию, принимающую три аргумента: указатель на первый элемент диапазона в массиве, указатель на элемент, следующий за концом этого
	//диапазона, и значение int.Функция должна присвоить каждому элементу диапазона массива это значение int.
	void SetInt(int *mas, int *fin, int num)
	{
		for (int* i = mas; *i < *fin; i++)
		{
			*i = num;
		}
	}


//5. Напишите функцию, прийимающую имя массива double и его размер в качестве аргументов и возвращающую наибольшее значение,
	//которое содержится в этом массиве.Обратите внимание, что функция не должна модифицировать содержимое массива.
	double GetMax(const double mas[], int size)
	{
		if (size < 0)return 0;

		double max = mas[0];
		for (int i = 1; i < size; i++)
		{
			if (max < mas[i])
				max = mas[i];
		}
		return max;
	}

//6. Почему вы не используете квалификатор const для аргументов функций, относящихся к любому из базовых типов ?
	//Базові типи передають в функцію копію змінної, тому вихыдны даны не потребують захисту.

//7. Каковы три формы строк в стиле С могут встретиться в программах C++ ? Функции как программные модули C++ 363
	//Константне значення в подвійних лапках.
	//Масив char
	//Покажчик на перший символ в строці

//8. Напишите функцию, имеющую следующий прототип: int replace(char* str, char c1, char c2); 
	//Эта функция должна заменять каждое появление с1 в строке str на с2 и возвращать количество выполненных замен.
	int replace(char* str, char c1, char c2)
	{
		int count = 0;
		while (*str)
		{
			if (*str == c1)
			{
				*str = c2;
				count++;
			}
			str++;
		}
		return count;
	}

//9. Что означает выражение * "pizza" ? А как насчет "taco"[2] ?
	//*"pizza" - показчик(адреса) на перший елемент масива
	//"taco"[2] - значення елемента, під індексом "2"

//10. C++ позволяет передавать структуры по значению, а также передавать адрес структуры.Если glitz — структурная переменная, как передать ее по значению? Как передать ее адрес ? Каковы преимущества и недостатки обоих подходов ?
	//Щоб передати по значенню, потрібно передавати імя структури glitz.
	//Щоб передати адрес, потрібно передати "&glitz"

//11. Функция judge() имеет тип возврата int.В качестве аргумента она принимает адрес функции.Функция, адрес которой ей передается, в свою очередь, принимает аргумент типа const char и возвращает int.Напишите прототип функции.
	int judge(int(*fun)(const char *))
	{}

//12. Предположим, что есть следующее объявление структуры :
	struct applicant {
		char name[30];
		int credit_ratings[3];
	};

	//а.Напишите функцию, которая принимает структуру applicant в качестве аргумента и отображает ее содержимое.
	void ShowApplicant(applicant app)
	{
		cout << app.name;
		for (int i = 0; i < 3; i++)
			cout << app.credit_ratings[i];
	}

	//б.Напишите функцию, которая принимает адрес структуры applicant в качестве аргумента и отображает содержимое структуры, на которую он указывает.
	void ShowApplicant(applicant *app)
	{
		cout << app->name;
		for (int i = 0; i < 3; i++)
			cout << app->credit_ratings[i];
	}
	
//13. Предположим, что функции fl() и f2() имеют следующие прототипы :
	void f1(applicant* а);
	const char* f2(const applicant* al, const applicant* a2);
	//Объявите p1 как указатель на функцию f1, а р2 — как указатель на f2. 
	//Объявите ар как массив из пяти указателей того же типа, что и р1, и объявите ра как указатель на массив из десяти указателей того же типа, что и р2.Воспользуйтесь typedef.

typedef void (*pfl) (applicant*);
pfl p1 = f1; 
typedef const char* (*pf2) (const applicant*, const applicant*);
pf2 p2 = f2;
pfl ap[5];
pf2(*pa)[10];
